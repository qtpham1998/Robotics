from __future__ import print_function # use python 3 syntax but make it compatible with python 2
from __future__ import division       #                           ''

import time     # import the time library for the sleep function
import brickpi3 # import the BrickPi3 drivers
import random
from math import pi, cos, sin
from os import system

BP = brickpi3.BrickPi3() # Create an instance of the BrickPi3 class. BP will be the BrickPi3 object.

leftMotor = BP.PORT_B
rightMotor = BP.PORT_C
NUMBER_OF_PARTICLES = 100
OFFSETX = 200
OFFSETY = 100
particleSet = []

class Particle:
    def __init__(self, x, y, theta, w=1/NUMBER_OF_PARTICLES):
        self.x = x
        self.y = y
        self.theta = theta
        self.w = w

    def calcX(self, dist):
        return self.x + (dist + random.gauss(0, 5)) * cos(self.theta / 180 * pi)

    def calcY(self, dist):
        return self.y + (dist + random.gauss(0, 5)) * sin(self.theta / 180 * pi)

    def calcTheta(self, degrees):
        return self.theta + degrees + random.gauss(0, 5) 
    
    def updateParticleCoords(self, dist):
        #return Particle(self.calcX(dist), self.calcY(dist), self.theta)
        return updateParticle(self, dist, None)
    
    def updateParticleAngle(self, degrees):
        #return Particle(self.x, self.y, self.calcTheta(degrees))
        return updateParticle(self, None, degrees)

    def updateParticle(self, dist, degrees):
        x = self.x
        y = self.y
        theta = self.theta
        if(dist != None):
            x = self.calcX(dist)
            y = self.calcY(dist)
        if(degrees != None):
            theta = self.calcTheta(degrees)
        return Particle(x, y, theta)
        
    def getCoords(self):
        return (self.x * 4 + OFFSET, self.y * 4 + OFFSET, self.theta)

def initialise():
    system('clear')
    for i in range(NUMBER_OF_PARTICLES):
        particleSet.append(Particle(0,0,0))
    BP.set_motor_limits(leftMotor, 70, 200)
    BP.set_motor_limits(rightMotor, 70, 200)

def calculateTargetDistance(dist):
    return 1.5 * (dist / (7.3 * pi)) * 360

def resetEncoder():
    try:
        BP.offset_motor_encoder(leftMotor, BP.get_motor_encoder(leftMotor))
        BP.offset_motor_encoder(rightMotor, BP.get_motor_encoder(rightMotor))
    except IOError as error:
        print (error)

def getMotorDps():
    return BP.get_motor_status(leftMotor)[3], BP.get_motor_status(rightMotor)[3]

def wait():
    print("Waiting for robot to stop.")
    time.sleep(1)
    vLeft, vRight = getMotorDps()
    while(vLeft != 0 or vRight != 0):
        vLeft, vRight = getMotorDps()
    print("Wait finished")

def moveForward(dist): # distance in cm
    print("Moving forward %d cm" %dist)
    resetEncoder()
    targetDist = calculateTargetDistance(dist) 
    BP.set_motor_position(leftMotor, -targetDist)
    BP.set_motor_position(rightMotor, -targetDist)

def rotateDegree(degrees):
    print("Rotating %d degrees" %degrees)
    resetEncoder()
    pos = calculateTargetDistance(degrees / 360 * 14 * pi)
    BP.set_motor_position(rightMotor, pos)
    BP.set_motor_position(leftMotor, -pos)
    updateParticles(None, degrees)
    
def moveLine(dist):
    for i in range(4):
        moveForward(dist)
        wait()
        updateParticles(dist, None)

def updateParticles(dist, degrees):
    for i in range(len(particleSet)):
        particleSet[i] = particleSet[i].updateParticle(dist, degrees)
    drawParticleSet()
    #newSet = []
    #for p in particleSet:
    #    newSet.append(p.updateParticle(dist, degrees))
    #particleSet =  newSet

def moveSquare(num):
    for n in range(num):
        for i in range(4):
            moveLine(10)
            wait()
            rotateDegree(90)
            wait()

def coordAxis():
    print("drawLine:" + str((0, 0, 0, 5000)))
    print("drawLine:" + str((0, 0, 5000, 0)))
          
def drawParticleSet():
    particles = [p.getCoords() for p in particleSet]
    print("drawParticles:" + str(particles))

try:
    initialise()
    coordAxis()
    moveSquare(1)


except KeyboardInterrupt:
    BP.reset_all()
